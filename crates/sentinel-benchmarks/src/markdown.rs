//! Markdown summary generation for benchmark results.
//!
//! This module provides functionality for generating markdown-formatted
//! summaries of benchmark results.

use crate::result::BenchmarkResult;
use chrono::Utc;

/// Generate a markdown summary from benchmark results.
pub fn generate_summary(results: &[BenchmarkResult]) -> String {
    let mut md = String::new();

    // Header
    md.push_str("# LLM-Sentinel Benchmark Summary\n\n");
    md.push_str(&format!(
        "Generated: {}\n\n",
        Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    ));

    if results.is_empty() {
        md.push_str("No benchmark results available.\n");
        return md;
    }

    // Overview section
    md.push_str("## Overview\n\n");
    md.push_str(&format!("- **Total Benchmarks**: {}\n", results.len()));

    // Group results by target_id
    let mut targets: std::collections::HashMap<&str, Vec<&BenchmarkResult>> =
        std::collections::HashMap::new();

    for result in results {
        targets
            .entry(&result.target_id)
            .or_default()
            .push(result);
    }

    md.push_str(&format!("- **Unique Targets**: {}\n\n", targets.len()));

    // Results table
    md.push_str("## Benchmark Results\n\n");
    md.push_str("| Target ID | Timestamp | Metrics Summary |\n");
    md.push_str("|-----------|-----------|----------------|\n");

    for result in results {
        let metrics_summary = summarize_metrics(&result.metrics);
        md.push_str(&format!(
            "| {} | {} | {} |\n",
            result.target_id,
            result.timestamp.format("%Y-%m-%d %H:%M:%S"),
            metrics_summary
        ));
    }

    md.push('\n');

    // Detailed results by target
    md.push_str("## Detailed Results\n\n");

    for (target_id, target_results) in &targets {
        md.push_str(&format!("### {}\n\n", target_id));

        for result in target_results {
            md.push_str(&format!(
                "**Run at {}**\n\n",
                result.timestamp.format("%Y-%m-%d %H:%M:%S UTC")
            ));

            md.push_str("```json\n");
            if let Ok(json) = serde_json::to_string_pretty(&result.metrics) {
                md.push_str(&json);
            }
            md.push_str("\n```\n\n");
        }
    }

    // Footer
    md.push_str("---\n\n");
    md.push_str("*Generated by LLM-Sentinel Benchmark Framework*\n");

    md
}

/// Generate a brief metrics summary for table display.
fn summarize_metrics(metrics: &serde_json::Value) -> String {
    if let Some(obj) = metrics.as_object() {
        let summaries: Vec<String> = obj
            .iter()
            .take(3) // Limit to first 3 metrics
            .map(|(k, v)| format!("{}={}", k, format_value(v)))
            .collect();

        let summary = summaries.join(", ");
        if obj.len() > 3 {
            format!("{}, ...", summary)
        } else {
            summary
        }
    } else {
        metrics.to_string()
    }
}

/// Format a JSON value for display.
fn format_value(value: &serde_json::Value) -> String {
    match value {
        serde_json::Value::Number(n) => {
            if let Some(f) = n.as_f64() {
                format!("{:.2}", f)
            } else {
                n.to_string()
            }
        }
        serde_json::Value::String(s) => s.clone(),
        serde_json::Value::Bool(b) => b.to_string(),
        serde_json::Value::Null => "null".to_string(),
        _ => "...".to_string(),
    }
}

/// Generate a comparison summary between two sets of results.
pub fn generate_comparison(baseline: &[BenchmarkResult], current: &[BenchmarkResult]) -> String {
    let mut md = String::new();

    md.push_str("# Benchmark Comparison\n\n");
    md.push_str(&format!(
        "Generated: {}\n\n",
        Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
    ));

    md.push_str("## Summary\n\n");
    md.push_str(&format!("- **Baseline Results**: {}\n", baseline.len()));
    md.push_str(&format!("- **Current Results**: {}\n\n", current.len()));

    // Create a map of current results by target_id
    let current_map: std::collections::HashMap<&str, &BenchmarkResult> = current
        .iter()
        .map(|r| (r.target_id.as_str(), r))
        .collect();

    md.push_str("## Comparison\n\n");
    md.push_str("| Target ID | Status | Notes |\n");
    md.push_str("|-----------|--------|-------|\n");

    for baseline_result in baseline {
        let status = if current_map.contains_key(baseline_result.target_id.as_str()) {
            "âœ… Present"
        } else {
            "âŒ Missing"
        };

        md.push_str(&format!(
            "| {} | {} | |\n",
            baseline_result.target_id, status
        ));
    }

    // Check for new targets in current
    let baseline_ids: std::collections::HashSet<&str> =
        baseline.iter().map(|r| r.target_id.as_str()).collect();

    for current_result in current {
        if !baseline_ids.contains(current_result.target_id.as_str()) {
            md.push_str(&format!(
                "| {} | ğŸ†• New | |\n",
                current_result.target_id
            ));
        }
    }

    md.push('\n');

    md
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_generate_summary_empty() {
        let summary = generate_summary(&[]);
        assert!(summary.contains("No benchmark results available"));
    }

    #[test]
    fn test_generate_summary_with_results() {
        let results = vec![
            BenchmarkResult::new("target_a", json!({"latency_ms": 10.5, "throughput": 1000})),
            BenchmarkResult::new("target_b", json!({"memory_mb": 128})),
        ];

        let summary = generate_summary(&results);

        assert!(summary.contains("# LLM-Sentinel Benchmark Summary"));
        assert!(summary.contains("target_a"));
        assert!(summary.contains("target_b"));
        assert!(summary.contains("Total Benchmarks"));
    }

    #[test]
    fn test_generate_comparison() {
        let baseline = vec![
            BenchmarkResult::new("target_a", json!({"value": 1})),
            BenchmarkResult::new("target_b", json!({"value": 2})),
        ];

        let current = vec![
            BenchmarkResult::new("target_a", json!({"value": 1})),
            BenchmarkResult::new("target_c", json!({"value": 3})),
        ];

        let comparison = generate_comparison(&baseline, &current);

        assert!(comparison.contains("âœ… Present")); // target_a
        assert!(comparison.contains("âŒ Missing")); // target_b
        assert!(comparison.contains("ğŸ†• New")); // target_c
    }
}
